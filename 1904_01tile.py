N = int(input())

dp = [0 for _ in range(N + 1)]

dp[1] = 1

if N != 1:
	dp[2] = 2

for i in range(3, N + 1):
	dp[i] = (dp[i - 1] + dp[i - 2]) % 15746

print(dp[N])

# [실버3] 1904 - 01타일
# https://www.acmicpc.net/problem/1904
# 220218_#1 경우의 수 문제를 대수적으로만 보려고 하면 함정에 빠진다

"""
어렵지 않은 문제였는데 쉬운 풀이가 며칠동안 생각나지 않았다.

N == 1 일 때의 case 때문에 오답률이 높은 문제.

입력에 따른 조건을 만들 수 있는 경우를 이전 조건과의 규칙에서 찾아내는게 dp의 핵심.
N자리 수를 만들기 위해서는 N-2자리 수와 N-1자리 수에서 파생될 것이라는건 쉽게 알 수 있는 사실.
많이 풀어보면 좀 빨리 캐치할 수 있어지려나...

<review> : maybe 3 or more
"""